The visParser (located in \texttt{kernel/src/visParser.js}) creates the list of templates that resides within the form module, for each template it creates a dictionary that binds a property name together with it's formula. The formula is also built by the visParser. It is an abstract syntax tree made of the possible expressions that are allowed within a formula.

The parsing of the file is initiated by a call to the parseForm that immediately calls the parseTemplate function. While the next token is not pointing to the end of the file and a template separator is encountered, it will keep building new templates until all templates declared in the file have been scanned and stored as an in-memory object in the template list.

\lstinputlisting[
    caption={maker function for creating a template},
    label={lst:makeTemplate}
]{code/form/makeTemplate.js}

\lstinputlisting[
    caption={function for parsing a template},
    label={lst:parseTemplate}
]{code/visParser/parseTemplate.js}

The parser uses the createTemplate method from the form module (show in listing~\ref{lst:makeTemplate}) in order to create a new template. Creating such a template requires a little care to whether the file declares a ``form header'' or not. A form header is used to set properties relative to the form, which are evaluated to values transferred onto the canvas (the scene on which components are rendered). The first 3 lines of the vis file in listing~\ref{lst:visfileReference} are properties of a form header. It is a special type of template and it's presence can be deduced by checking if the first declared template addresses an existing component type in the canvas or not. If it doesn't that template must be a form header and in this case, the template's component type is set to ``Canvas''. This template represents the \emph{root element} of the template tree. If the file declares no form header, a default template is created with it's componentType addressing the ``Canvas'' type and it is used as the root element in the template tree. As an improvement for readability, the type inference of the first template could possibly be separated into it's own function. The entire procedure for parsing a template is shown in listing~\ref{lst:parseTemplate}

For each parsed template, a call to the parseProperty function is made. It reads the property key, skips the semi colon symbol that separates it from the formula and parses the formula by calling parseFormula. Finally the property is returned as an object with a key and a formula.

\lstinputlisting[
    caption={function for parsing a formula},
    label={lst:parseFormula}
]{code/visParser/parseFormula.js}

A formula can be anything from a simple value to a binary expression, through a path. When calling parseFormula, a formula object is created and returned. At this point, the parsing process becomes interesting. Listing~\ref{lst:parseFormula} shows exactly what happens: While we do not meet the End of a line, we build the formula value by calling the function maybeBinary. We pass the function maybePath as a parameter to maybeBinary and we pass the function parseAtom into maybePath. Mihai Bazon explains very well the sense of the maybe* functions: they ``check what follows after an expression in order to decide whether to wrap that expression in another node, or just return it as is.''\cite{bazon16}.

\lstinputlisting[
    caption={maybePath, a function that eventually triggers a call to parsePath},
    label={lst:maybePath}
]{code/visParser/maybePath.js}

The maybePath function shown in listing~\ref{lst:maybePath} is a very understandable example in order to illustrate this. It takes an atomic expression as an input value. It checks whether the next character is a punctuation or not. If it so, the expression is used to compute a path, otherwise, the expression is returned as is.

\subsubsubsection{Path}

\lstinputlisting[
    caption={function that parses a path},
    label={lst:parsePath}
]{code/visParser/parsePath.js}

The path is very important. It is a key element to enable the possibility for a designer to walk into different areas of the system. How the path is built now, will facilitate later on, the task of exploring that path. Listing~\ref{lst:parsePath} shows how it is done. 

According to the reference card~\cite{refCard}, a path can start with either a punctuation with the symbol dot (``.'') or bang (``!'') or it can start with an identifier. In my current implementation, I only read paths starting with an identifier but it would be trivial to add support for paths starting with a punctuation.

\lstinputlisting[
    caption={Example of a path node as generated by the parser for the expression \texttt{Map.Person[3]!Name}},
    label={lst:path}
]{code/visParser/path.js}

The main idea behind the parsePath function is to look at the type of the current expression. If it is an identifier and that the next token is a punctuation with a bang or a dot symbol, we keep building the path. Similarly if it is a punctuation and that the next token is an identifier we keep constructing the path. Note that in order to extend the path the parsePath function is called recurcively. This will result in a nice path object whose components are nested. Listing~\ref{lst:path} shows an example of the expression \texttt{Map.Person[3]!Name} after it has been transformed into a token of type path. The index is set when the expression is followed by a pair of square bracket delimiters ``['' and ``]''.

\subsubsubsection{Operator precedence}

The maybeBinary function in listing~\ref{lst:parseBinary} is used to parse binary expressions. To parse them properly, it relies on the precedence table in listing~\ref{lst:precedence}. The precedence helps to determine the order in which operations should be executed. In this expression \texttt{1 + 2 * 3}, the multiplication (``*'') binds tighter that the addition (``+''), it should be computed first.

\lstinputlisting[
    caption={precedence},
    label={lst:precedence}
]{code/visParser/precedence.js}

\lstinputlisting[
    caption={function for parsing a binary expression},
    label={lst:parseBinary}
]{code/visParser/parseBinary.js}

In order to construct a binary expression, a first atomic expression is passed to the \texttt{maybeBinary} function (it's \texttt{left} argument) together with it's precedence (it's \texttt{myPrec} argument, 0 if none). The maybeBinary looks at the next token. If it is not an operator or if it has a smaller precedence level, the \texttt{left} value remains untouched and is returned. If the precedence level of the operator is higher, the expression is extended as much as necessary to the right and the value of \texttt{left} is nested into a new binary expression. This new binary expression is returned through the maybeBinary function.

In other words, similarly as for the maybePath function, an expression that is not an operand of a binary expression, will just go as it came in, through the function.

The expression \texttt{Form.Person -< Map.Activity} is another example of a valid binary expression. In this case it's operands are paths. An important job of the interpreter will be to find and use the values of the objects addressed in the path. This is what I will discuss in the very next section.

What I discussed here shows how the dynamic nature of JavaScript can be taken advantage of in order to compose an entire syntax tree on the basis of simple functions that all together serve a more general purpose. What I like with this approach is that functions are always executed independently of the context in which they are called from. Earlier, when I talked about the components, I showed how in certain cases, in JavaScript the execution context needs to be explicitly bound to a function. When the program is entirely relying on functions through which the objects are progressively composed, the inner state of these functions are always independent on any external context, they only depend on what values they are given as input by other functions.

The kernel has two distinct parsers for parsing the vism files and the vis files. They both use the same tokenizer. It is arguable that the vis parser itself could be split into two distinct parsers. One for building the template and properties and another one for parsing the formulas. This could possibly improve the readability.

When a vis file has been parse the actual interpretation of the abstract syntax tree can be done.
