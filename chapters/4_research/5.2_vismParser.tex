The data contained in the vismParser (located in \texttt{kernel/src/vismParser.js}) is semantically extremely simple. It's lines contain key value pairs where the value is an expression that is so simple that I did not find it necessary to build an AST and to have an interpreter specifically for these expressions. I rather read and use the values directly from within the vismParser. At this stage, my principal concern was to get the values and correctly prepare the system so that I could focus on interpreting the vis file.

The vismParser uses the ``system'' module (located in \texttt{kernel/src/system.js}) to set the StartUpForm (the name of the vis file to open upon startup). Then the data-map is constructed. The data-map holds the knowledge about what resources can be addresses, how they relate to each other and where and how they can be downloaded\dots In order to better separate concerns, I have isolated the data-map into a it's own JavaScript module that is called ``map'' (located in \texttt{kernel/src/map.js}). 

The vismParser uses the ``map'' in order to store constant values that must be integrated to all requests that will, at some point in time, be sent to the database (rows limit, simulated time\dots).

It is then used again in order to set the database informations: The provider and the source. The map module holds an internal ``Database'' object that is used as a dictionary to hold these two parameters. The source is a simple string that is a ``url'' or a relative ``url path'' that refers to some endpoint on the domain server. The provider is a more complex object that needs to be clarified:

It is a simple JavaScript object with three functions that are all written specifically for a given database vendor and that all serves a specific purpose:
\begin{itemize}
    \item parser - A function that takes an external schema description representing the schema of the database and that parses it. It transforms it into a meaningful schema object that can be sent by the kernel to the mapper as the ``external schema''. 
    \item mapper - A function that takes the ``external schema'' object and compares it to the schema specified at the bottom of the current vism file. The mapper saves all of the resources (tables) described in the vism file and tries to find it's equivalent in the external schema. All fields for the given resource are then saved from the external schema to the system's schema. A final schema that represents the comparison of the internal and the external schema is then returned.
    \item translator - A method that takes a queryModel as generated by the kernel (this will come after the pre-evaluation phase, when trying to allocate the data) and transforms it into a query string.
\end{itemize}

The system should be able to interact with different database vendors. In the same way as for the components in the canvas module, my implementation enables the local developer to register new types of database providers through the ``registerProvider'' function. The screens from the sample application are produced with data coming from a PostgreSQL database. The current implementation comes with a built-in provider called ``pgsql'' that is meant to illustrate the idea behind the database provider.

After this section, in the discussion I will come back to the connection between the system and the database layer. It's a sensitive question. I have made lots of experiments, notably with OData. I will come back to this. This is just for saying that I am well aware of the fact that the way I do handle the data connection currently is not optimal.

\lstinputlisting[
    caption={JavaScript object literal as being produced by the vism parser after parsing file in listing~\ref{lst:vismfileReference}},
    label={lst:internalSchema}
]{code/map/internalSchema.js}

The vismParser builds an internal schema object that contains a separate definition of all the tables mentioned in the vism file and the connection between these tables. Listing~\ref{lst:internalSchema} shows the JavaScript object literal as being produced by the vism parser after parsing file in listing~\ref{lst:vismfileReference}.